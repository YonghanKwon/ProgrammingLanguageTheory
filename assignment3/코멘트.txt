go언어를 사용하여 제작하였으며, 제출물은 src파일에 존재한 것을 가정하고 작성하였습니다. 혹시 몰라 소스코드를 txt파일에 넣어 함께 제출합니다.
num_init은 int와 float형의 구현이 담겨있으며, 계산 가능한 구조체의 interface 정보 또한 있습니다.
num_extend의 경우 rational과 complex의 구현이 있고 calculator는 이러한 계산 가능한 것들을 담는 stack과 계산기에 현재 찍혀있는 숫자에 대한 정보를 가지고 있는 구조체가 구현되어 있습니다.
go언어는 static typechecking을 하지만 duck typing을 지원하여 interface의 함수를 구현하는 모든 구조체를 calculable이라는 이름으로 사용할 수 있습니다.  때문에 이후에 확장되어 사용되는 rational과 complex의 경우 기존의 num_init과 calculator가 충분히 확장성이 좋다면 기존 코드 내부의 수정이 없이 구현이 가능하였습니다.
연산 과정에서 구체적인 형이 아닌 interface로 입력을 받아 입력된 값의 경우엔 멤버변수에 접근할 수 없어 멤버변수의 값을 얻을 수 있는 GetValue함수가 interface의 함수에 추가되었으며, 이때 이후 연산에서 사용되기에 구체적인 값이 필요하지만 구체적으로 어떤 값이 입력되는지는 알 수 없기에 string타입을 반환하게 하여 타입에 상관없이 타입별 적절한 값을 얻을 수 있으며, string을 int나 float와 같은 형으로 변환하기 위해선 기존에 어떤 형이였는지에 대한 정보가 필요하여 이 정보를 각 구조체의 멤버변수 중 checker에 담아 두었습니다. (int형-0, float-100, rational-50, complex-150+a 이때 a는 complex의 real과 imaginary부분이 어떤 형인지에 따라 결정됩니다.)
struct의 함수에서 입력된 값이 interface형이기에 구체적인 멤버변수가 없으며, 입력된 값의 경우 interface에 정의된 함수만을 사용하여 값에 접근할 수 있습니다. 이를 통해 정보은닉과 캡슐화가 구현되며, interface를 모두 구현한다면 interface형의 구체적인 형으로 사용할 수 있어 이를 통해 dynamic binding을 이룰 수 있습니다.